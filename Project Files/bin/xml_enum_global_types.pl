#!/usr/bin/perl -w


use strict;
use warnings;

use Data::Dumper;

use XML::LibXML::Reader;
use lib './bin';
use XMLlists;


my @enums;
my %enumValues;

my @enumsToSkip =
(
	"AnimationOperatorTypes",
	"FunctionTypes",
	"DiplomacyPowerTypes",
	"AutomateTypes",
	"DirectionTypes",
	"InterfaceVisibility",
	"ArtStyleTypes",
	"ContactTypes",
	"CitySizeTypes",
	"FootstepAudioTypes",
);

my @enumsToNotUseEnumCounter =
(
	"AnimationOperatorTypes",
	"ArtStyleTypes",
	"AutomateTypes",
	"FootstepAudioTypes",
);


my $FILE         = getAutoDir() . "/AutoGlobalDefineEnum.h";
my $FILE_CPP     = getAutoDir() . "/AutoGlobalDefineEnumCpp.h";
my $FILE_CASE    = getAutoDir() . "/AutoGlobalDefineEnumCase.h";

my $output         = "";
my $output_case    = "";

$output .= "#ifndef AUTO_XML_ENUM_GLOBAL\n";
$output .= "#define AUTO_XML_ENUM_GLOBAL\n";
$output .= "\n";
$output .= "// Autogenerated file. Do not edit!!!\n";
$output .= "\n";



getTypesInFile("GlobalTypes.xml");



foreach my $enum (@enums)
{
	next if shouldSkipEnum($enum);
	
	$output .= "enum " . $enum . "\n{\n";
	$output .= "\tNO_" . getEnumUpperCase($enum) . " = -1,\n";
	
	foreach my $value (@{$enumValues{$enum}})
	{
		$output .= "\t";
		$output .= $value;
		$output .= ",\n";
	}
	my $upperName = getEnumUpperCase($enum);
	
	$output .= "\n\t" . getMaxName($upperName) . ",\n";
	$output .= "\t" . getFirstName($upperName) . " = 0,\n";
	$output .= "};\n\n";
}

foreach my $enum (@enums)
{
	next if shouldSkipEnum($enum);
	my $upperName = getEnumUpperCase($enum);
	my $numTypes = getMaxName($upperName);
	my $first = getFirstName($upperName);
	my $jit = "JIT_ARRAY_" . $upperName;
	
	addgetIndexOfTypeCase($enum, $jit);
	
	handleOperators($enum);
	
	$output .= "template <> struct VARINFO<" . $enum . ">\n{\n";
	$output .= "\tstatic const JITarrayTypes JIT = " . $jit . ";\n";
	$output .= "\tstatic const $enum DEFAULT = static_cast<$enum>(-1);\n";
	$output .= "\tstatic const char* getName() { return \"" . $enum . "\";}\n";
	$output .= "\tstatic const VariableTypes TYPE = (int)" . $numTypes . " < 128 ? VARIABLE_TYPE_CHAR : VARIABLE_TYPE_SHORT;\n";
	$output .= "\tstatic const VariableLengthTypes LENGTH_KNOWN_WHILE_COMPILING = VARIABLE_LENGTH_ALL_KNOWN;\n";
	$output .= "\tstatic const $enum FIRST = " . $first . ";\n";
	$output .= "\tstatic const $enum END = " . $numTypes . ";\n";
	$output .= "\tstatic const $enum LAST = " . $numTypes . ";\n";
	$output .= "\tstatic const $enum NUM_ELEMENTS = " . $numTypes . ";\n";
	$output .= "\tstatic const $enum LENGTH = " . $numTypes . ";\n";
	$output .= "\tstatic $enum start() { return " . $first . ";}\n";
	$output .= "\tstatic $enum end() { return " . $numTypes . ";}\n";
	$output .= "\tstatic $enum length() { return $numTypes;}\n";
	$output .= "\tstatic bool isInRange($enum eIndex) { return eIndex >= FIRST && eIndex <= LAST;}\n";
	$output .= "\ttemplate <int T> struct STATIC {\n";
	$output .= "\t\tstatic const VariableStaticTypes VAL = T * ((int)TYPE == (int)VARIABLE_TYPE_CHAR ? 1 : 2) <= 4 ? VARIABLE_TYPE_STATIC : VARIABLE_TYPE_DYNAMIC;\n";
	$output .= "\t};\n";
	$output .= "};\n";
	
	handleInfoArray($enum, $jit);
}

$output .= "#endif\n";

writeFile($FILE        , \$output        );

$output = "\n// autogeneted file!\n// do not edit\n\n";
$output .= "#include \"../CvEnumsFunctions.h\"\n\n";

foreach my $enum (@enums)
{
	$output .= "\ntemplate<>\n";
	$output .= "const char* getTypeStr(" . $enum . " eIndex)\n{\n";
	$output .= "\tswitch(eIndex)\n\t{\n";
	
	my $i = 0;
	foreach my $value (@{$enumValues{$enum}})
	{
		$output .= "\t\tcase ";
		if (useEnumNamesAsCounter($enum))
		{
			$output .= $value;
		}
		else
		{
			$output .= $i;
			$i = $i + 1;
		}
		$output .= ": return \"" . $value . "\";\n";
	}
	$output .= "\t}\n";
	$output .= "\treturn \"\";\n";
	$output .= "}\n";

}

writeFile($FILE_CPP     , \$output        );
writeFile($FILE_CASE    , \$output_case   );


exit();



sub getTypesInFile
{
	my $filename = shift;
	
	my $fileWithPath = getFileWithPath($filename);
	
	if ($fileWithPath)
	{
		my $reader = XML::LibXML::Reader->new(location => $fileWithPath)
			or die "cannot read file '$fileWithPath': $!\n";
		
		my $enumSet = 0;
		my $enum = "";
		
		
		while($reader->read)
		{
			if ($reader->nodeType == 1 and $reader->depth == 1)
			{
				$enumSet = 0;
				$enum = getEnumName($reader->name);
			}
			elsif ($reader->nodeType == 3 and $reader->depth == 3)
			{
				if ($enumSet == 0)
				{
					$enumSet = 1;
					push(@enums, $enum);
					$enumValues{$enum} = ();
					
				}
				push(@{$enumValues{$enum}}, $reader->value);
			}
		}
	}
}

sub getEnumName
{
	my $enum = shift;
	return "InterfaceVisibility" if $enum eq "InterfaceVisibilityTypes";
	return $enum;
}

sub getMaxName
{
	my $name = shift;
	
	return "MAX_NUM_SYMBOLS" if $name eq "FONT_SYMBOLS";
	
	return "NUM_" . $name . "_TYPES";
}

sub getFirstName
{
	my $name = shift;
	
	return "FIRST_FONTSYMBOL" if $name eq "FONT_SYMBOLS";
	
	return "FIRST_" . $name;
}

sub shouldSkipEnum
{
	my $enum = shift;
	
	foreach my $loop_enum (@enumsToSkip)
	{
		return 1 if $enum eq $loop_enum;
	}
	return 0;
}

sub useEnumNamesAsCounter
{
	my $enum = shift;
	
	foreach my $loop_enum (@enumsToNotUseEnumCounter)
	{
		return 0 if $enum eq $loop_enum;
	}
	return 1;
}

sub getChild
{
	my $parent = shift;
	my $name = shift;
	
	my $element = $parent->firstChild;
	
	while (1)
	{
		return if (ref($element) eq "");
		if (ref($element) eq "XML::LibXML::Element")
		{
			return $element if $name eq "" or $element->nodeName eq $name;
		}
		$element = $element->nextSibling;
	}
}

sub nextSibling
{
	my $element = shift;
	
	$element = $element->nextSibling;
	while (ref($element) ne "XML::LibXML::Element" and ref($element) ne "")
	{
		$element = $element->nextSibling;
	}
	return $element;
}

sub removeType
{
	my $type = shift;
	if (substr($type, -5) eq "Types")
	{
		$type = substr($type, 0, -5);
	}
	return $type;
}

sub getEnumUpperCase
{
	my $original = shift;
	my $result = substr($original, 0, 1);
	
	$original = substr($original, 1);
	
	if (substr($original, -5) eq "Types")
	{
		$original = substr($original, 0, -5);
	}
	
	foreach my $char (split //, $original)
	{
		my $newChar = uc($char);
		$result .= "_" if $char eq $newChar;
		$result .= $newChar;
	}
	
	return $result;
}

sub handleOperators
{
	my $type = shift;
	
	operatorAdd($type, "+");
	operatorAdd($type, "-");
	
	operator($type, "++", 0);
	operator($type, "++", 1);
	operator($type, "--", 0);
	operator($type, "--", 1);
}

sub operator
{
	my $type = shift;
	my $operator = shift;
	my $postfix = shift;
	
	$output .= "static inline $type";
	$output .= "&" unless $postfix;
	$output .= " operator" . $operator . "($type& c";
	$output .= ", int" if $postfix;
	$output .= ")\n";
	$output .= "{\n";
	$output .= "\t" . $type . " cache = c;\n" if $postfix;
	$output .= "\tc = static_cast<$type>(c " . substr($operator, 0, 1) . " 1);\n";
	$output .= "\treturn ";
	$output .=  "c" unless $postfix;
	$output .=  "cache" if $postfix;
	$output .= ";\n";
	$output .= "};\n";
}

sub operatorAdd
{
	my $type = shift;
	my $operator = shift;
	
	$output .= "static inline $type operator" . $operator . "(const $type& A, const $type& B)\n";
	$output .= "{\n";
	$output .= "\treturn static_cast<$type>((int)A $operator (int)B);\n";
	$output .= "};\n";
}

sub addgetIndexOfTypeCase
{
	my $type = shift;
	my $jit  = shift;
	
	return if $jit eq "NO_JIT_ARRAY_TYPE";
	
	$output_case .= "\t\tcase $jit:\n";
	$output_case .= "\t\t{\n";
	$output_case .= "\t\t\t$type eTmp;\n";
	$output_case .= "\t\t\treturn getIndexOfType(eTmp, szType);\n";
	$output_case .= "\t\t}\n";
}

sub handleInfoArray
{
	my $type = shift;
	my $jit  = shift;
	
	return if $jit eq "NO_JIT_ARRAY_TYPE";
	
	handleInfoArraySingle($type, 1);
	handleInfoArraySingle($type, 2);
	handleInfoArraySingle($type, 3);
	handleInfoArraySingle($type, 4);

}sub handleInfoArraySingle
{
	my $type = shift;
	my $id = shift;
	my $get = "get" . removeType($type);
	my $index = $id - 1;
	
	$get = "getFontSymbol" if $get eq "getFontSymbols";
	
	$output .= "template<" . addtemplates("typename T", $id, 0) . ">\nclass InfoArray$id<" . addtemplates("T", $id, 1) . $type . ">\n\t: ";
	$output .= "public InfoArray$index<" . addtemplates("T", $id, 0) . ">\n" unless $id == 1;
	$output .= "protected InfoArrayBase\n\t, public boost::noncopyable\n" if $id == 1;
	$output .= "{\n";
	$output .= "\tfriend class CyInfoArray;\n";
	$output .= "public:\n";
	if ($id == 1)
	{
		$output .= "\tint getLength() const\n\t{\n\t\treturn InfoArrayBase::getLength();\n\t}\n";
		$output .= "\t$type get(int iIndex) const\n";
		$output .= "\t{\n";
		$output .= "\t\treturn static_cast<$type>(getInternal(iIndex, $index));\n";
		$output .= "\t}\n";
	}
	$output .= "\t$type get$index(int iIndex) const\n";
	$output .= "\t{\n";
	$output .= "\t\treturn static_cast<$type>(getInternal(iIndex, $index));\n";
	$output .= "\t}\n";
	$output .= "\t$type $get(int iIndex) const\n";
	$output .= "\t{\n";
	$output .= "\t\treturn static_cast<$type>(getInternal(iIndex, $index));\n";
	$output .= "\t}\n";
	$output .= "\tint getIndexOf($type eValue) const\n";
	$output .= "\t{\n";
	$output .= "\t\treturn _getIndexOf(eValue, $index);\n";
	$output .= "\t}\n";
	$output .= "protected:\n";
	$output .= "friend class CvCity;\n" if $id == 1;
	$output .= "friend class CvGlobals;\n" if $id == 1;
	$output .= "friend class CivEffectInfo;\n" if $id == 1;
	$output .= "friend class CvPlayerCivEffect;\n" if $id == 1;
	$output .= "friend class CvInfoBase;\n" if $id == 1;
	$output .= "\tInfoArray$id(JITarrayTypes eType0, JITarrayTypes eType1, JITarrayTypes eType2, JITarrayTypes eType3)\n";
	$output .= "\t\t: InfoArray" . ($id - 1) . "<" . addtemplates("T", $id, 0) . ">(eType0, eType1, eType2, eType3) {}\n" unless $id == 1;
	$output .= "\t\t: InfoArrayBase(eType0, eType1, eType2, eType3) {}\n" if $id == 1;
	$output .= "};\n";
}

sub addtemplates
{
	my $str = shift;
	my $id = shift;
	my $append_comma = shift;
	
	my $return = "";
	
	my $i = 1;
	
	return $return if $i == $id;
	$return .=  $str . "0";
	$i = 2;
	
	while ($i < $id)
	{
		$return .=  ", " . $str . ($i - 1);
		$i += 1;
	}
	
	$return .= ", " if $append_comma;
	return $return;
}
